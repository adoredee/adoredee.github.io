<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<title>
  
     C&#43;&#43;之查漏补缺 | 
    adoredee
  
</title><meta name="description" content="Thy know not I knew thee"><meta name="author" content="kangzhiheng">

<link rel="apple-touch-icon" href="/apple-touch-icon.png" sizes="180x180">
<link rel="icon" href="/favicon-32x32.png " sizes="32x32" type="image/png">
<link rel="icon" href="/favicon-16x16.png" sizes="16x16" type="image/png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#0c344b">
<link rel="icon" href="/favicon.ico">


    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/themes/prism.min.css">
    



    
        
            <link rel="stylesheet" href="/dist/main.37ab3f61b95417873748.min.css">
        
    




<link rel="canonical" href="https://www.kangzhiheng.top/post/3-c&#43;&#43;%E7%9F%A5%E8%AF%86%E7%82%B9/"><meta property="og:title" content="C&#43;&#43;之查漏补缺" />
<meta property="og:description" content="关于C&#43;&#43;的一些知识点，方便查阅。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.kangzhiheng.top/post/3-c&#43;&#43;%E7%9F%A5%E8%AF%86%E7%82%B9/" />
<meta property="og:image" content="https://www.kangzhiheng.top/3-cover.png" />
<meta property="article:published_time" content="2020-02-15T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-02-15T00:00:00+00:00" /><meta property="og:see_also" content="https://www.kangzhiheng.top/post/5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" /><meta property="og:see_also" content="https://www.kangzhiheng.top/post/4-linux%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" /><meta property="og:see_also" content="https://www.kangzhiheng.top/post/6-tcp-ip%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/" />

<meta itemprop="name" content="C&#43;&#43;之查漏补缺">
<meta itemprop="description" content="关于C&#43;&#43;的一些知识点，方便查阅。">
<meta itemprop="datePublished" content="2020-02-15T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2020-02-15T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="11006">
<meta itemprop="image" content="https://www.kangzhiheng.top/3-cover.png">



<meta itemprop="keywords" content="C&#43;&#43;," /><meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://www.kangzhiheng.top/3-cover.png"/>

<meta name="twitter:title" content="C&#43;&#43;之查漏补缺"/>
<meta name="twitter:description" content="关于C&#43;&#43;的一些知识点，方便查阅。"/>


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-166758556-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-166758556-1');
</script>

</head>
<body>
    
<nav class="navbar navbar-expand-md navbar-light bg-light fixed-top shadow-sm" id="navbar-main-menu">
    <div class="container">
        <a class="navbar-brand font-weight-bold" href="https://www.kangzhiheng.top/">adoredee</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#main-menu" aria-controls="main-menu" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="main-menu">
            <ul class="navbar-nav ml-auto">

                
                    <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/post/">Archives</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/categories/">Categories</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/tags/">Tags</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/series/">Series</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/system/">System</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/share/">Share</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/life/">Life</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/poems/">Poems</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/about/">About</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/search/">Search</a></li>
                
            
            </ul>
        </div>
    </div>
</nav>




    
<main class="content-page container pt-7 pb-5">
    
    <div class="row">
        <div class="col">
            <article>
                <div class="row justify-content-center">
                    <div class="col-lg-12">
                        <div class="meta text-muted mb-3">
                            <p class="created text-muted text-uppercase font-weight-bold mb-1">February 15, 2020</p>
                            <span class="mr-2"><i class="fas fa-book-open mr-2"></i></span>
                            <span><i class="fas fa-clock mr-2"></i></span>
                        </div>

                        <h1>C&#43;&#43;之查漏补缺</h1>

                        <ul class="authors list-inline"><li class="list-inline-item mr-3">
                    <div class="media author"><a href="/authors/kangzhiheng/" class="mr-3">
                                    <picture>
                                        <source srcset="/authors/kangzhiheng/refrain_huc96af13c0d53ef6b21ac652a00d8e2ed_60914_64x0_resize_q75_box.jpg 1x, /authors/kangzhiheng/refrain_huc96af13c0d53ef6b21ac652a00d8e2ed_60914_128x0_resize_q100_box.jpg 2x, /authors/kangzhiheng/refrain_huc96af13c0d53ef6b21ac652a00d8e2ed_60914_192x0_resize_q100_box.jpg 3x">
                                        <img src="/authors/kangzhiheng/refrain_huc96af13c0d53ef6b21ac652a00d8e2ed_60914_64x0_resize_q75_box.jpg" class="rounded-circle" alt="Kangzhiheng">
                                    </picture>
                                </a><div class="media-body">
                            <h5 class="name my-0"><a href="/authors/kangzhiheng/" class="small">Kangzhiheng</a>
                            </h5><p class="social small text-muted">
                                    <a href="https://github.com/kangzhiheng">@kangzhiheng</a>
                                </p></div>
                    </div>
                </li></ul>
                    </div>
                </div><div class="row justify-content-center mb-3">
                                <div class="col-lg-10">
                                    <img data-src="/images/3-cover_hu6edfe1933026989421229eeb3bb92281_38697_900x500_fit_box_2.png" class="img-fluid rounded mx-auto d-block" alt="C&#43;&#43;之查漏补缺">
                                </div>
                            </div>
<h4>目录</h4>
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title"></h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#静态函数可以是内联函数吗"><strong>静态函数可以是内联函数吗？</strong></a>
      <ul>
        <li></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>                
                <div class="row justify-content-center">
                    <div class="col-lg-12">
                        <div class="content">
                            <p>关于C++的一些知识点，方便查阅。</p>
<h4 id="基础">基础</h4>
<ol>
<li>
<p>程序运行包括？预处理器包括？</p>
</li>
<li>
<p>动态链接和静态链接</p>
</li>
<li>
<p><strong>#include &lt;&gt; 和#include &ldquo;&ldquo;的区别</strong></p>
<p>这两个都可以将指定的文件中的内容引入到当前文件，但在搜索时采用了不同的搜索策略。</p>
<ul>
<li>#include &lt;&gt;在搜索时直接从编译器指定的路径开始搜索，如<strong>D:\Program Files\Microsoft Studio 10.0\VC\include</strong>；</li>
<li>#include &ldquo;&ldquo;首先从运行程序所在的目录处进行搜索，如果搜索失败再从编译器指定的路径处搜索，如果仍然搜索失败，程序直接报错。</li>
</ul>
</li>
</ol>
<h4 id="关键字">关键字</h4>
<ol>
<li>
<p><strong>const</strong></p>
<p><strong>作用：</strong></p>
<ul>
<li>
<p>修饰<strong>指针</strong>，分为<strong>常量指针</strong>和<strong>指针常量</strong>；</p>
</li>
<li>
<p>修饰<strong>变量</strong>，作用：修饰<strong>变量</strong>，说明该变量不可以被修改；</p>
</li>
<li>
<p><strong>常量引用</strong>，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；</p>
</li>
<li>
<p>修饰<strong>类成员函数</strong>， 不能更新任何数据成员，也不能调用该类中没有用const修饰的成员函数，只能<strong>调用常成员函数</strong>和<strong>常数据成员</strong>， 但是可以被其他成员函数调用；</p>
</li>
</ul>
<p><strong>使用分析：</strong></p>
<pre><code class="language-C++">// 定义一个类
class A
{
private:
    const int a;                    // 常对象成员，只能在初始化列表（构造函数）里赋值
public:
    // 构造函数
    A() : a(0) {};
    A(int x) : a(x) {};             // 初始化列表
       
    int getValue();                 // 普通成员函数
    int getValue() const;           // 常成员函数，不能更新任何数据成员（也就是不能在函数里对私有变量赋值），只能调用常成员函数和常数据成员。
}
   
void function()
{
    // 对象
    A b;                            // 普通对象
    const A a;                      // 常对象，只能调用常成员函数
    const A *p = &amp;a;				// 常指针
    const A &amp;q = a;					// 常变量
       
    // 指针
    char greeting[] = &quot;Hello&quot;;		
    char* p1 = greeting;			// 指针变量
    const char* p2 = greeting;		// 常量指针
    char* const p3 = greeting;		// 指针常量
    const char* const p4 = greeting;// 
}
   
// 函数
void func1(const int var);			// 传递过来的参数在函数内不可变
void func2(const char* var);		// 常量指针，参数指针所指的内容为常量
void func3(char* const var);		// 指针常量
void func4(const int&amp; var);			// 引用参数在函数内为常量
   
// 函数返回值
const int func5();					// 返回一个整型常量
const int* func6();					// 返回一个指向常量的指针变量，const int* p = func6();
int* const func7();					// 返回一个指向指针类型的常量，int* const p = func7();
</code></pre>
</li>
<li>
<p><strong>static</strong></p>
<p><strong>作用</strong>：</p>
<ol>
<li>
<p>修饰<strong>静态成员变量</strong>， 在类里的成员变量的声明前加上关键字static，那么该数据成员就是类内的静态数据成员。 <strong>该类的所有对象只保存这一个变量，在初次使用时就被初始化</strong>，而且不需要生成对象就可以访问该成员；</p>
</li>
<li>
<p>修饰<strong>静态成员函数</strong>，静态成员函数为类服务，而不是某一个类的具体对象。</p>
<ul>
<li><strong>普通的成员函数一般都隐含了一个this指针</strong>，this指针指向类的对象本身，因为普通成员函数总是属于类的某个具体的对象；</li>
</ul>
<ul>
<li>类的静态成员函数属于类本身，不作用于对象，因此不具有this指针，正因为它没有指向某一个对象，所以它无法访问属于类对象的非静态成员变量和非静态成员函数，它只能调用其余的静态成员函数和静态成员变量；</li>
<li>由于没有this指针的额外开销，静态成员函数与类的全局函数相比速度上会稍快；</li>
</ul>
</li>
<li>
<p>修饰<strong>静态全局变量</strong>，在全局变量前，加上关键字<code>static</code>，该变量即为静态全局变量。 在一个文件中，静态全局变量和全局变量功能相同；而在两个文件中，要使用同一个变量，则只能使用全局变量而不能使用静态全局变量。</p>
</li>
<li>
<p>修饰<strong>静态局部变量</strong>，在局部变量前，加上关键字<code>static</code>，该变量就被定义为一个静态局部变量。</p>
<ul>
<li><strong>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</strong>  静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；</li>
<li>静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；</li>
<li>静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；</li>
</ul>
</li>
<li>
<p>修饰<strong>静态函数</strong>， 在函数的返回类型前加上static关键字,函数即被定义为静态函数。  静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。</p>
<ul>
<li>静态函数不能被其它文件所用；</li>
<li>其它文件中可以定义相同名字的函数，不会发生冲突；</li>
</ul>
</li>
</ol>
<blockquote>
<p>静态函数可以是虚函数吗？</p>
<ul>
<li>static不属于任何类对象或类实例，所以即使给此函数加上<strong>virutal</strong>也是没有任何意义的；</li>
<li>静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数没有<strong>this指针</strong>；虚函数依靠指针vptr和虚函数表vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable。对于静态成员函数，它没有this指针，所以无法访问vptr. 这就是为何static函数不能为virtual.
<strong>虚函数的调用关系：this -&gt; vptr -&gt; vtable -&gt;virtual function</strong></li>
</ul>
</blockquote>
</li>
<li>
<p><strong>define宏定义</strong></p>
<p><strong>作用：</strong></p>
<ul>
<li>宏定义：提高程序的可读性</li>
<li><strong>仅仅是字符串的替换</strong></li>
</ul>
<p><strong>宏定义与内联函数的区别</strong>：</p>
<ol>
<li>宏定义是字符串的替换，内联函数是一个函数；</li>
<li>代码展开在程序的不同阶段：<strong>宏定义</strong>的展开是在预处理阶段，<strong>内联函数</strong>是编译阶段；</li>
<li>内联函数在运行时可调试，而宏定义不可以。</li>
</ol>
</li>
<li>
<p><strong>inline内联函数</strong></p>
<p><strong>优点</strong>：</p>
<ul>
<li>不执行进入函数的步骤，<strong>直接执行函数体</strong>；内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>代码膨胀</strong>。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接；</li>
<li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器；</li>
<li><strong>内联函数（inline）可以是虚函数（virtual）吗？</strong>
<ul>
<li><strong>内联函数</strong>需要在<strong>编译阶段</strong>展开，而<strong>虚函数</strong>是运行时<strong>动态绑定</strong>的，<strong>inline</strong>关键字作为提示符<strong>建议</strong>编译器此函数作为内联函数希望在编译阶段展开，但是，<strong>编译器并不一定要展开</strong>；</li>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，<strong>但是当虚函数表现为多态性的时候不能内联</strong>（内联是在编译器<strong>建议</strong>编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。）；</li>
<li>inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who() ），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生；</li>
</ul>
</li>
<li>
<h2 id="静态函数可以是内联函数吗"><strong>静态函数可以是内联函数吗？</strong></h2>
</li>
</ul>
</li>
<li>
<p><strong>volatile</strong></p>
<p><strong>作用</strong>：</p>
<ul>
<li>volatile 关键字声明的变量，提醒编译器它后面所定义的变量随时有可能改变，volatile 告诉编译器不应对这样的对象进行优化，<strong>因此</strong>每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）；</li>
<li>一个变量既可以是<strong>const</strong>还可以是<strong>volatile</strong>（ 只读的状态寄存器 ）；</li>
<li>指针可以是 volatile；</li>
</ul>
<p><strong>例子：</strong></p>
<pre><code class="language-C++">vilatile int a = 10;
int b = a;
int c = a;
</code></pre>
<p>若忽略<code>volatile</code>，那<strong>变量a</strong>就只需要从内存中读取一次就够了。因为从内存中读取一次之后，CPU 的寄存器中就已经有了这个值；把这个值直接复用就可以了。这样一来，编译器就会做优化，把两次访存的操作优化成一次。</p>
<p><strong>但是</strong>， 例如说，假设 <code>a</code> 指向的内存是一个硬件设备。这样一来，从 <code>a</code> 指向的内存读取数据可能伴随着<strong>可观测的副作用</strong>：硬件状态的修改。此时，代码的原意可能是将硬件设备返回的连续两个 <code>int</code> 分别保存在 <code>b</code> 和 <code>c</code> 当中。这种情况下，编译器的优化就会导致程序行为不符合预期了。</p>
<p>总结来说，被 <code>volatile</code> 修饰的变量，在对其进行读写操作时，会引发一些<strong>可观测的副作用</strong>。而这些可观测的副作用，是由<strong>程序之外的因素决定的</strong>。</p>
<p><a href="https://liam.page/2018/01/18/volatile-in-C-and-Cpp/">Volatile关键字参考链接</a></p>
</li>
<li>
<p><strong>new/delete和malloc/free</strong></p>
<ul>
<li>
<p>malloc/free是C/C++库函数，通过函数调用访问，需要传递参数并接受返回值；</p>
<p>new/delete是C++运算符，有自己的一套语法规则和运算方式；</p>
</li>
<li>
<p>malloc函数返回的是void *类型，程序需要显示的转换程所需要的基本类型；</p>
<p>new操作直接指明类型，不涉及类型转换问题；</p>
</li>
<li>
<p>内存分配：malloc需要显式的指定内存块大小，new不需要；</p>
</li>
<li>
<p>new可以调用malloc，但是malloc不可用调用new；</p>
</li>
<li>
<p>new/delete允许重载，malloc/free不允许重载；</p>
</li>
</ul>
</li>
<li>
<p><strong>delete与delete []区别</strong></p>
<ul>
<li>当new[]中的数组元素是<strong>基本类型</strong>时，通过delete和delete[]都可以释放数组空间；</li>
<li>当new[]中的数组元素是<strong>自定义类型</strong>时，只能通过delete[]释放空间，因为delete[]会逐个调用数组中每个对象的析构函数，只有这样才能讲数组元素内部申请的资源释放，从而将整个对象数组完全释放，不会造成内存泄漏；</li>
</ul>
</li>
<li></li>
</ol>
<h4 id="指针和引用">指针和引用</h4>
<ol>
<li>
<p><strong>指针和引用的区别</strong></p>
<p><strong>知识点梳理</strong>：</p>
<p><strong>引用</strong>：变量的别名，就是给一个变量重新起了一个名字。</p>
<pre><code class="language-C++">int val = 2;
int &amp;rval = val;			// 定义一个引用，且初始化
</code></pre>
<p>上述代码中，定义了一个整型<strong>变量</strong><code>val</code>，紧接着定义了一个<strong>引用</strong><code>rval</code>并初始化。</p>
<p><code>Notice</code>：</p>
<ol>
<li>引用在定义时必须初始化，所以其与一个变量绑定在一起，初始化后，引用不能再绑定其他变量，<strong>对引用修改就是对所绑定变量的修改</strong>；</li>
<li>引用并不是值的拷贝，而是将两者绑定在一起，变量<code>val</code>和<code>rval</code>是等效的；</li>
</ol>
<p><strong>适用场合</strong>：<strong>函数参数的传递</strong>。在被调函数内修改形参就相当于修改了主调函数的实参，通过这种方式改变实参并没有数量的限制；</p>
<p><strong>好处</strong>：将函数声明为引用，就是可以避免对象的拷贝。如果函数占用了很大的空间，值传递可以就拷贝整个对象的空间，另外，程序可读性更强。</p>
<pre><code class="language-C++">Class Object
{// 实现省略，只需要知道我们在这里声明了一个类，在下面我们要将这个类的对象作为
 // 函数参数类型来使用};
void fun1(Object obj)    // 值传递
{
     // 此函数声明中，obj是值传递，会产生一个临时对象
}
void fun2(Object &amp;obj)   // 引用传递
{
    // 我们不用检查obj是否为空，同时，使用引用传递，可以避免临时对象
}
</code></pre>
<p><strong>特殊使用</strong>——<strong>常量引用初始化</strong>。</p>
<pre><code class="language-C++">int &amp;a = 10;			// 错误。引用是变量的别名，而10是常量10；
const int &amp;a = 10;		// 正确。
</code></pre>
<p>上述代码第二行是可以执行代码的，编译器对这种操作进行特殊处理，具体如下：</p>
<pre><code class="language-C++">int tmp = 10;				// 第一步：将常量存放在一个临时变量中
const int &amp;a = tmp;			// 第二步：使用临时变量进行初始化
</code></pre>
<p><strong>参考回答</strong>：</p>
<ul>
<li>
<p>**指针是变量的地址，引用是变量的别名。**指针的值是另一个变量的地址，而引用是别名，所以在某些运算方面，有着一定的差异</p>
<ol>
<li>
<p><strong>sizeof运算符</strong>（x64环境下测试）</p>
<pre><code class="language-C++">int a = 10;						// 原始变量
int *p = &amp;a;					// 指针p指向变量a的地址
int &amp;c = *p;					// *p结果为a，引用c指向的原变量a，c是a的别名
cout &lt;&lt; sizeof(p) &lt;&lt; endl;		// 指针本身所占的空间，8个字节
cout &lt;&lt; sizeof(c) &lt;&lt; endl;		// 取决于原变量的大小，a为int，4个字节
</code></pre>
</li>
<li>
<p><strong>自增运算符</strong>。指针自增，指向下一个地址空间，引用自增，是对原变量的自增。</p>
</li>
</ol>
</li>
<li>
<p><strong>指针可以不初始化，引用必须初始化。</strong>（<strong>空指针可以有，空引用不能有</strong>） 对于指针来说，它是一个地址，这个地址是一个数值，那么就意味这个数值可以为0(空指针)，也可以为其他，即指针可以不指向任何东西；而对于引用来说，他是一个外号，外号一定是“某个存在物体”的外号，所以引用不能为空，即不能存在空引用。</p>
</li>
<li>
<p><strong>指针需要解引用，引用直接使用。</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>指针常量和常量指针</strong></p>
<p><strong>知识点梳理：</strong></p>
<ul>
<li><strong>指针常量 — 指针类型的常量</strong>，本质上是一个常量。（指针符号在前，const在后。）</li>
</ul>
<pre><code class="language-C++">int a = 10;
int* const p = &amp;a;
*p = 30;
</code></pre>
<ol>
<li><code>const</code>修饰指针<code>p</code>，因此指针<code>p</code>是常量，故<strong>指针<code>p</code>指向的地址不可用改变</strong>；</li>
<li><code>*p</code>是可以改变的，也就是<strong><code>p</code>指向的地址的内容是可以更改的</strong>；</li>
</ol>
<ul>
<li><strong>常量指针 — 指向“常量”的指针</strong>。（const在前，指针符号在后）</li>
</ul>
<pre><code class="language-C++">int a = 10;
const int* p = &amp;a;
</code></pre>
<ol>
<li><code>const</code>修饰<code>*p</code>的，因此<code>*p</code>的内容不可以更改；</li>
<li><code>p</code>本身是一个地址，所以<code>p</code>是可以改变的；</li>
</ol>
</li>
<li>
<p><strong>this指针</strong></p>
</li>
</ol>
<h4 id="内存管理">内存管理</h4>
<ol>
<li>
<p>在程序中，数据存储在不同的区段，通常分为<strong>5个部分</strong>：</p>
<ul>
<li><strong>栈存储区</strong>：主要存储<strong>函数参数</strong>和<strong>局部变量</strong>，这部分数据的空间由编译器负责分配和回收，效率高，存储数据时采取“<strong>后进先出</strong>”的方式；分配容量有限；</li>
<li><strong>堆存储区</strong>：主要存储<strong>动态分配的内存块</strong>，程序员负责分配和回收， 如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收;</li>
<li><strong>全局/静态存储区</strong>：主要存储<strong>全局变量</strong>和<strong>静态变量</strong>，这类变量比较特殊，其生命周期在程序运行期间始终存在，程序结束时操作系统才会回收这部分空间；</li>
<li><strong>常量存储区</strong>： 这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。</li>
<li><strong>自由存储区</strong>： 就是那些由<code>malloc</code>等分配的内存块，他和堆是十分相似的，不过它是用<code>free</code>来结束自己的生命的；</li>
</ul>
</li>
<li>
<p><strong>栈和堆的区别</strong></p>
<pre><code class="language-c++">int *p = new int[5];
</code></pre>
<p>上述语句就包含了堆和栈，<code>new</code>，表示分配了一块堆内存，<code>p</code>是局部指针变量，分配的一块栈内存，所以这句话的意思就是：<strong>在栈内存中存放了一个指向一块堆内存的指针p</strong>。</p>
<p>区别：</p>
<ul>
<li><strong>管理方式</strong>：
<ul>
<li>栈：由编译器自动管理，无需手动控制；</li>
<li>堆：释放工作由程序员控制，容易产生memory leak(内存泄漏)；</li>
</ul>
</li>
<li><strong>空间大小</strong>
<ul>
<li>栈：有一定大小空间限制，是一块连续的内存的区域，比较小，几M；</li>
<li>堆：不连续的区域，大小受限于计算机的虚拟内存，堆获得的空间比较灵活，也比较大；</li>
</ul>
</li>
<li><strong>碎片问题</strong>
<ul>
<li>栈：栈是先进后出的队列，是一块连续的内存区域；</li>
<li>堆：频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低；</li>
</ul>
</li>
<li><strong>生长方向</strong></li>
<li>栈：生长方向是向下的，是向着内存地址减小的方向增长；</li>
<li>堆：生长方向是向上的，是向着内存地址增加的方向增长；</li>
<li><strong>分配方式</strong></li>
<li>栈
- 静态分配：是编译器完成的，比如局部变量的分配
-  动态分配：由<code>alloca</code>函数进行分配，由编译器自动释放</li>
<li>堆：只有动态分配</li>
</ul>
</li>
<li>
<p><strong>内存泄漏</strong></p>
<ul>
<li>使用<strong>智能指针</strong>代替普通指针，因为智能指针自带<strong>引用计数</strong>功能，能够动态分配空间的引用数量，在引用技术为零时，自动调用析构函数释放空间；</li>
<li>借助一些内存泄漏检测工具；</li>
<li>程序员<strong>良好的编程习惯</strong>：malloc/free、new/delete成对出现；</li>
</ul>
</li>
<li>
<p><strong>智能指针</strong></p>
<p>为什么需要<strong>智能指针</strong>？</p>
<p>C++内存管理是一个头疼的问题，因为在确保在正确的时间释放内存是及其困难的。为了更容易和更安全的使用动态内存，建议使用<strong>智能指针</strong>。</p>
<p>头文件：<code>#include &lt;memory&gt;</code></p>
<ul>
<li>
<p><strong>C++ 98  —&gt; auto_ptr</strong></p>
<pre><code class="language-c++">auto_ptr&lt;string&gt; ps (new string(str));
</code></pre>
</li>
<li>
<p><strong>C++ 11</strong></p>
<ul>
<li>shared_ptr</li>
<li>unique_ptr</li>
<li>weak_ptr</li>
<li>auto_ptr（C++ 11弃用）</li>
</ul>
</li>
<li>
<p><strong>shared_ptr</strong>：<strong>多个智能指针可以共享同一个对象的所有权</strong>，通过<strong>引用计数</strong>指向同一对象的智能指针个数，每增加一个智能指针指向对象时，引用计数加1，功能对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源；</p>
</li>
<li>
<p><strong>weak_ptr</strong>：weak_ptr是一种不控制所有对象生存期的智能指针，它指向由一个shared_ptr管理的对象，将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最末一个指向对象的shared_ptr被销毁，对象就被释放，即使有weak_ptr指向对象；</p>
</li>
<li>
<p><strong>unique_ptr</strong>：与shared_ptr不同，<strong>某个时刻只能有一个unique_ptr指向一个给定的对象</strong>。当unique_ptr被销毁时，它所指向的对象也被销毁；<strong>unique_ptr唯一拥有所指向对象的所有权，不支持拷贝和赋值操作，只能通过move函数将其所有权转移给其它智能指针</strong>；</p>
</li>
</ul>
<ol>
<li>
<p>设计思想： <strong>将基本类型指针封装为类对象指针，并在析构函数里编写delete语句删除指针指向的内存；</strong></p>
</li>
<li>
<p>为什么摒弃<strong>auto_ptr</strong>？ <strong>避免潜在的内存崩溃问题。</strong></p>
<pre><code class="language-c++">auto_ptr&lt;string&gt; ps(new string(&quot;I am very happy!&quot;));
auto_ptr&lt;string&gt; pt;
pt = ps;
</code></pre>
<p>一个对象只能由一个auto_ptr所拥有，在给其他auto_ptr赋值的时候，<strong>会转移这种拥有关系，原指针在失去对象所有权时成为空指针</strong>。因此<code>pt = ps </code>，<code>pt</code>接管<code>ps</code>所有权，<code>ps</code>所有权被剥夺，这两个指针将指向同一个string对象。这是不能接受的，因为程序将试图删除同一个对象两次——一次是ps过期时，另一次是pt过期时。</p>
</li>
<li>
<p><strong>unique_ptr为什么优于auto_ptr？</strong></p>
<pre><code class="language-c++">auto_ptr&lt;string&gt; p1(new string(&quot;auto&quot;));
auto_ptr&lt;string&gt; p2;
p2 = p1;      								// #3
</code></pre>
<p>在语句#3中，p2接管string对象的所有权后，p1的所有权将被剥夺。前面说过，这是好事，可防止p1和p2的析构函数试图刪同—个对象；但如果程序随后试图使用p1，这将是件坏事，因为p1不再指向有效的数据。</p>
<pre><code class="language-C++">unique_ptr&lt;string&gt; p3 (new string (&quot;auto&quot;);   //#4
unique_ptr&lt;string&gt; p4；                       //#5
p4 = p3;                                      //#6
</code></pre>
<p>编译器认为语句#6非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。</p>
<p>unique_ptr禁止赋值操作。<strong>unique_ptr在内存安全性、充当容器元素和支持动态数组方面均优于auto_ptr。</strong></p>
<p><a href="https://www.cnblogs.com/lanxuezaipiao/p/4132096.html">智能指针参考链接</a></p>
</li>
<li>
<p><strong>环状引用问题及其解决方案</strong></p>
<p>**两个shared_ptr指针所指向对象的数据成员中，如果含有指向对象的shared_ptr指针，则会产生环状引用。**环状引用导致释放资源时发生死锁，引用计数不会降为0，造成对象空间无法释放，这时就需要weak_ptr，因为不会改变shared_ptr的引用计数。</p>
</li>
<li>
<p><strong>shared_ptr线程安全问题</strong></p>
<p>boost官方文档描述：</p>
<ul>
<li>
<p>一个 <strong>shared_ptr</strong> 实例可以同时被多个线程“读”（仅使用不变操作进行访问）；</p>
</li>
<li>
<p>不同的 <strong>shared_ptr</strong> 实例可以同时被多个线程“写入”（使用类似<strong>operator=</strong> 或 <strong>reset</strong> 这样的可变操作进行访问）（即使这些实例是拷贝，而且共享下层的引用计数）。</p>
<blockquote>
<p>所谓的原子操作，取的就是“原子是最小的、不可分割的最小个体”的意义，它表示在多个线程访问同一个全局资源的时候，能够确保所有其他的线程都不在同一时间内访问相同的资源。也就是他确保了在同一时刻只有唯一的线程对这个资源进行访问。这有点类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高。</p>
</blockquote>
</li>
<li>
<p><strong>shared_ptr</strong>的引用计数本身是安全且无锁的，但对象的读写则不是，因为 shared_ptr 有两个数据成员，读写操作不能原子化；</p>
</li>
<li>
<p><strong>shared_ptr</strong>引用计数是<strong>原子</strong>的，它的析构函数原子地将引用计数减去1，当<strong>多个线程对同一对象析构时</strong>，也只会出现执行顺序的交错，不会有内存泄露。 那么同理shared_ptr的<strong>构造函数</strong>、<strong>赋值</strong>、<strong>析构</strong>都是线程安全的；</p>
</li>
<li>
<p><strong>不同的shared_ptr对象可以被多线程同时修改</strong>（即使这些shared_ptr对象管理着同一个对象的指针）；</p>
</li>
<li>
<p>如果要从多个线程读写同一个 <strong>shared_ptr</strong> 对象，无法确保编译器是先操作引用计数还是先操作指针，在这个时候就需要加锁， 那么需要<strong>加锁</strong>。</p>
</li>
</ul>
<p><a href="https://www.jianshu.com/p/c75a0d33655c">https://www.jianshu.com/p/c75a0d33655c</a></p>
</li>
</ol>
</li>
</ol>
<h4 id="面向对象">面向对象</h4>
<ol>
<li>
<p>三大特征：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong></p>
<ul>
<li>
<p><strong>封装</strong>： **细节隐藏，使代码模块化。**C++支持数据封装，类是支持数据封装的工具，对象是数据封装的实现。封装体与外界进行信息交换是通过操作接口进行的,这种访问控制机制体现在类的成员可以有公有成员(public)，私有成员(private)，保护成员(protected)。</p>
<ul>
<li>public 成员：可以被任意实体访问；</li>
<li>private 成员：只允许被本类的成员函数、友元类或友元函数访问；</li>
<li>protected 成员：只允许被子类及本类的成员函数访问；</li>
</ul>
</li>
<li>
<p><strong>继承</strong>：基类（父类）——&gt; 派生类（子类）</p>
<p>**扩展已存在的代码模块，充分利用代码资源。**C++语言允许单继承和多继承。继承是面向对象语言的重要特性。一个类可以根据需要生成它的派生类，派生类还可以再生成派生类。派生类继承基类的成员，另外，还可以定义自己的成员。继承是实现抽象和共享的一种机制。</p>
<p>具体来讲：<strong>继承</strong>是指这样一种能力：<strong>它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。其继承的过程，就是从一般到特殊的过程。<strong>通过继承创建的新类称为“子类”或“派生类”。被继承的类称为“基类”、“父类”或“超类”。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。继承的实现方式有三类：<strong>实现继承</strong>、接口继承和</strong>可视继承</strong>。</p>
<ul>
<li><strong>实现继承</strong>是指使用基类的属性和方法而无需额外编码的能力；</li>
<li><strong>接口继承</strong>是指仅使用属性和方法的名称、但是子类必须提供实现的能力；</li>
<li><strong>可视继承</strong>是指子窗体（类）使用基窗体（类）的外观和实现代码的能力；</li>
</ul>
</li>
<li>
<p><strong>多态</strong>： 多态性是指对不同类的对象发出相同的消息将会有不同的实现，也就是<strong>接口重用</strong>。通过<strong>重载</strong>（<strong>函数重载</strong>和<strong>运算符重载</strong>）和<strong>函数覆盖</strong>/<strong>重写</strong>两种方法实现。</p>
<ul>
<li>
<p><strong>重载</strong> —— 必须在同一类中，重载分为<strong>函数重载</strong>和<strong>运算符重载</strong></p>
<ul>
<li>
<p><strong>函数重载</strong>是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数；</p>
</li>
<li>
<p><strong>运算符重载</strong>是带有特殊名称的函数，函数名是由<strong>关键字 operator</strong> 和其后要重载的运算符符号构成的，与其他函数一样，重载运算符有一个返回类型和一个参数列表。运算符重载是对已有的运算符赋予多重含义，使同一个运算符作用域不同类型的数据导致不同行为的发生。</p>
<p>为了理解运算符重载，举一个例子，在C++中，“+”左右两边的对象可以是浮点型，也可以是整型，为什么同一个运算符&quot;+&quot;可以用于完成不同类型的数据的加法运算？这是因为C++针对预定义基本数据类型已经对&quot;+&quot;运算符做了适当的重载。在编译程序编译不同类型数据的加法表达式时，会自动调用相应类型的加法运算符重载函数。但是C++中所提供的预定义的基本数据类型毕竟是有限的，在解决一些实际的问题时，往往需要用户自定义数据类型。比如高中数学里所提到的复数，复数相加时，需要对应的实部和虚部分别相加再组合成新的复数，在C++里的加号“+”是不能完成这样的任务的，故C++提供了一种方法，即运算符重载函数，其函数名字规定为 operator后紧跟重载运算符。比如operator+或者operator*，请看例子：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
// 定义复数类
class Complex
{
public:
   double real;
   double imag;
   Complex(double real = 0, double imag = 0)
   {
       this-&gt;real = real;
       this-&gt;imag = imag;
   }
         
};
// 运算符重载
Complex operator+(Complex num1, Complex num2)
{
   return Complex(num1.real + num2.real, num1.imag + num2.imag);
}
         
int main()
{
   Complex num1(19, 20), num2(21, 20), sum;
   sum = operator+(num1, num2);
   cout &lt;&lt; &quot;复数相加：&quot; &lt;&lt; sum.real &lt;&lt; &quot; + i&quot; &lt;&lt; sum.imag &lt;&lt; endl;
         
   return 0;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>覆盖/重写</strong> —— 必须发生于父类与子类之间，并且父类与子类中的函数必须有完全相同的原型，<strong>使用virtual声明之后能够产生多态(如果不使用virtual，那叫重定义，这句话非常重要！！！)</strong> ，**即在派生类中重新对基类中的虚函数（注意是虚函数）重新实现，也就是说函数名和参数都一样，只是函数的实现体不一样。**多态是在运行期间根据具体对象的类型决定函数调用，<strong>虚函数来支持动态联编，动态联编是多态性的一个重要的特征</strong>。<strong>动态联编</strong>是指在程序执行的时候才将函数实现和函数调用关联，因此也叫运行时绑定或者晚绑定，动态联编对函数的选择不是基于指针或者引用，而是基于对象类型，不同的对象类型将做出不同的编译结果。 <strong>C++中一般情况下联编也是静态联编，但是一旦涉及到多态和虚拟函数就必须要使用动态联编了。</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>重载函数的二义性</strong></p>
</li>
<li>
<p><strong>构造函数和析构函数的执行顺序</strong></p>
<p>类的对象也是一个<strong>局部变量</strong>，局部变量存放在当前的作用域的<strong>栈</strong>中，因此构造函数在创建时，执行入栈操作，调用构造函数；销毁时，调用析构函数，执行出栈操作；</p>
</li>
<li>
<p><strong>类的默认成员函数</strong></p>
<pre><code class="language-C++">class Base
{
public:
    Base() {};				// 构造函数
    Base(const Base &amp;a);    // 拷贝构造函数
    Base &amp;operator = (const Base &amp;a);    // 运算符重载函数
    ~Base() {};				// 析构函数
}
</code></pre>
<ul>
<li><strong>构造函数</strong>：
<ul>
<li>构造函数是用于构造新对象，并将初始值赋给对象的数据成员。；</li>
<li>类型转化，适用于单参的构造函数；</li>
</ul>
</li>
<li><strong>拷贝构造函数</strong>
<ul>
<li>用此类已有的对象创建一个新的对象，一般在函数中会将已存在对象的数据成员的值复制一份到新创建的对象中。用类的一个已知的对象去初始化该类的另一个对象时，会自动调用对象的拷贝构造函数；</li>
<li>拷贝构造函数的参数必须使用<strong>引用传参</strong>，使用传值方式会引发无穷递归调用；</li>
<li>拷贝构造函数其实是一个构造函数的重载；</li>
<li><strong>浅拷贝和深拷贝</strong>：
<ul>
<li>编译器创建的默认拷贝构造函数只会执行&quot;浅拷贝&rdquo;，也就是通过赋值完成；</li>
<li>如果指针成员是<strong>new</strong>出来就是“深拷贝”， <strong>对象重新分配空间之后</strong>，然后将值拷贝的拷贝方式。 ；</li>
</ul>
</li>
</ul>
</li>
<li><strong>运算符重载函数</strong>
<ul>
<li>赋值运算符重载就是为了代码的可读性，比如我们两个类进行赋值的时候如果不写赋值运算符重载的话就要用一个函数来实现我们的赋值，函数在调用的时候可读性没有我们的“=”高，所以c++实现了运算符的重载；</li>
</ul>
</li>
<li><strong>析构函数</strong>
<ul>
<li>析构函数作用是做一些清理工作，delete一个对象或对象生命周期结束时，会自动调用对象的析构函数；</li>
<li>函数名在类名前加上字符~，没有参数（可以有void类型的参数），也没有返回值，可以为虚函数（通过基类的指针去析构子类对象时候），<strong>不能重载，故析构函数只有一个</strong>；</li>
<li>如果没有显式定义，编译器会自动生成一个默认的析构函数，默认的析构函什么都不会做；</li>
<li>析构顺序：和构造函数顺序相反。析构的过程也是递归的；</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>虚析构函数</strong></p>
<ul>
<li>
<p>当基类产生多个派生类时，析构函数可能只进行局部销毁，此时加上<code>virtual</code>关键字，将<strong>析构函数声明为虚析构函数</strong>，就可以解决对象的释放问题。</p>
</li>
<li>
<p><strong>构造函数不能为虚函数</strong>，因为在构造对象时，必须确切知道类型，才能正确的生成对象；</p>
</li>
</ul>
</li>
<li>
<p><strong>纯虚函数</strong></p>
<ul>
<li>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做；</li>
<li><strong>含有纯虚函数的类为抽象类，不能生成对象；</strong></li>
</ul>
</li>
<li>
<p><strong>虚继承</strong></p>
<ul>
<li>
<p><strong>多重继承</strong>：一个子类同时继承多个父类；比如：<strong>水上汽车兼具了汽车和轮船的特性</strong>；</p>
</li>
<li>
<p><strong>菱形继承</strong>：多个父类，又同时继承一个类，这时会产生二义性的问题，这个时候需要<strong>虚继承</strong>。</p>
<pre><code class="language-C++">class A
{
public: int a;
};
class B: virtual public A{};
class C: virtual public A{};
class D: public B, public: C{};    // 此时类D只有类A的一份拷贝
</code></pre>
<p>通过<code>virtual</code>来修饰继承关系，虚继承中的父类称为<strong>虚基类</strong>。</p>
</li>
</ul>
</li>
<li>
<p><strong>虚函数表</strong></p>
<ul>
<li>如果一个类中有<strong>虚函数</strong>，则这个类就对应一个虚函数表；</li>
<li>虚函数表中的元素是<strong>一组指向函数的指针</strong>，每个指针指向虚函数的入口地址；</li>
<li>在含有虚函数的类对象模型中，除了对象的数据成员外，还有一个指向虚函数表的指针，称为虚指针<strong>vptr</strong>，位于对象模型的顶部；</li>
<li>虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且<strong>只能用this指针来访问vptr</strong>，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable。
<strong>虚函数的调用关系：this -&gt; vptr -&gt; vtable -&gt;virtual function</strong></li>
</ul>
</li>
<li>
<p><strong>为什么在多态时，析构函数是虚函数？</strong></p>
<p><strong>答案： 为了防止内存泄漏。</strong></p>
<ul>
<li>析构函数不一定必须是虚函数，是否为虚函数取决于该类的使用，一般该类为基类产生继承和多态时，才会是虚函数，单独使用可以不是虚函数。之所以在继承和多态时设计为虚函数是因为<strong>当new派生类并且用基类指针指向这个派生类</strong>， 当删除基类指针指向的派生类对象时就不会触发<strong>动态绑定</strong>， <strong>在销毁基类指针时只会调用基类的析构函数</strong>，不会调用派生类的析构函数，因为基类无法操作派生类中非继承的成员， 那么在这种情况下，<strong>派生类中申请的空间就得不到释放从而产生内存泄漏</strong>。</li>
<li>默认不是虚析构函数是因为如果析构函数为虚函数就需要编译器在类中增加虚函数表来实现虚函数机制，这样所需内存空间就更大了，因此没有必要默认为虚析构函数；</li>
</ul>
</li>
<li>
<p>TODO</p>
</li>
</ol>
<h4 id="stl">STL</h4>
<ol>
<li>
<p>容器底部的构造</p>
<ul>
<li>
<p><strong>顺序容器</strong>：支持顺序访问元素的功能，根据元素在容器中的位置，按序依次访问容器中的每一个元素，包括：<strong>向量vector</strong>、<strong>双向链表list</strong>、<strong>双端数组 deque</strong>、<strong>string</strong>；</p>
</li>
<li>
<p><strong>适配器</strong>：举个例子：比如视频输出接口是DVI，显示器接口是HDMI，为了解决接口不匹配的问题，需要一根转换线，可以两种不同的接口连接起来，这就类似于STL里的<strong>适配器</strong>，即构造了一个容器接口到需求接口之间的转换器。</p>
<p>适配器对原容器进行了一层封装，低层基于普通容器，上层对外提供封装后的新接口，满足不同使用者的需求。</p>
<p>常用的适配器包括：<strong>栈stack、队列queue、优先级队列priority_queue</strong>；</p>
</li>
<li>
<p><strong>关联容器</strong>：set、map、multiset、multimap、</p>
</li>
</ul>
</li>
<li>
<p>vector和数组的不同</p>
</li>
<li>
<p>vector扩容</p>
</li>
<li>
<p>TODO</p>
</li>
</ol>
                        </div><div class="tags my-3"><a class="badge badge-pill badge-light border mr-2" href="/tags/c&#43;&#43;">
                                    <i class="fas fa-tag mr-2"></i>C&#43;&#43;
                                </a></div><ul class="share nav my-3 justify-content-end">
        <li class="nav-item">
            <a class="nav-link" target="_blank" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fwww.kangzhiheng.top%2fpost%2f3-c%2b%2b%25E7%259F%25A5%25E8%25AF%2586%25E7%2582%25B9%2f&text=C%2b%2b%e4%b9%8b%e6%9f%a5%e6%bc%8f%e8%a1%a5%e7%bc%ba">
              <i class="fa-fw fab fa-twitter"></i>
          </a>
        </li>
        <li class="nav-item">
            <a class="nav-link" target="_blank" href="https://www.linkedin.com/shareArticle?url=https%3a%2f%2fwww.kangzhiheng.top%2fpost%2f3-c%2b%2b%25E7%259F%25A5%25E8%25AF%2586%25E7%2582%25B9%2f&title=C%2b%2b%e4%b9%8b%e6%9f%a5%e6%bc%8f%e8%a1%a5%e7%bc%ba">
                <i class="fa-fw fab fa-linkedin-in"></i>
            </a>
        </li>
        <li class="nav-item">
            <a class="nav-link" target="_blank" href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fwww.kangzhiheng.top%2fpost%2f3-c%2b%2b%25E7%259F%25A5%25E8%25AF%2586%25E7%2582%25B9%2f&t=C%2b%2b%e4%b9%8b%e6%9f%a5%e6%bc%8f%e8%a1%a5%e7%bc%ba">
                <i class="fa-fw fab fa-facebook-f"></i>
            </a>
        </li>
        <li class="nav-item">
            <a class="nav-link" target="_blank" href="https://reddit.com/submit?url=https%3a%2f%2fwww.kangzhiheng.top%2fpost%2f3-c%2b%2b%25E7%259F%25A5%25E8%25AF%2586%25E7%2582%25B9%2f&title=C%2b%2b%e4%b9%8b%e6%9f%a5%e6%bc%8f%e8%a1%a5%e7%bc%ba">
                <i class="fa-fw fab fa-reddit-alien"></i>
            </a>
        </li>
        <li class="nav-item">
            <a class="nav-link" target="_blank" href="https://github.com/kangzhiheng?url=https%3a%2f%2fwww.kangzhiheng.top%2fpost%2f3-c%2b%2b%25E7%259F%25A5%25E8%25AF%2586%25E7%2582%25B9%2f&title=C%2b%2b%e4%b9%8b%e6%9f%a5%e6%bc%8f%e8%a1%a5%e7%bc%ba">
                <i class="fa-fw fab fa-github"></i>
            </a>
        </li>
    </nav>
                    </div>
                </div>

                <div class="row justify-content-center">
                    <div class="col-lg-8">
                        
                    </div>
                </div></article>
            
        </div>
    </div>
    
    
    <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
        const gitalk = new Gitalk({
            clientID: '63ea86b104bd9a73070a',
            clientSecret: '9d66cbaf6cf4e5d6400f0d081883eb9dc60d987e',
            repo: 'adoredee.github.io',
            owner: 'adoredee',
            admin: ['adoredee'],
            id: location.pathname, 
            distractionFreeMode: false 
        });
        (function() {
            if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
                document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
                return;
            }
            gitalk.render('gitalk-container');
        })();
    </script>


    
    
</main>


    <footer class="footer text-center bg-dark py-6">
    <div class="container">
        <div class="row">
            <div class="col">
                <ul class="list-inline">
                    <li class="list-inline-item"><a href="https://www.kangzhiheng.top/index.xml" rel="alternate" type="application/rss+xml" class="icons d-block">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-circle fa-stack-2x"></i>
                                        <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a></li><li class="list-inline-item">
                        <a href="mailto:kangzhiheng@live.cn" class="icons d-block">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li><li class="list-inline-item">
                            <a href="https://facebook.com" class="icons d-block">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fab fa-facebook fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li><li class="list-inline-item">
                            <a href="https://github.com/kangzhiheng" class="icons d-block">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li><li class="list-inline-item">
                            <a href="https://gitlab.com" class="icons d-block">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fab fa-gitlab fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li><li class="list-inline-item">
                            <a href="https://stackoverflow.com" class="icons d-block">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fab fa-instagram fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li><li class="list-inline-item">
                            <a href="https://linkedin.com" class="icons d-block">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li><li class="list-inline-item">
                            <a href="https://mastodon.social" class="icons d-block">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fab fa-mastodon fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li><li class="list-inline-item">
                            <a href="https://reddit.com" class="icons d-block">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fab fa-reddit fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li><li class="list-inline-item">
                            <a href="https://stackoverflow.com" class="icons d-block">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li><li class="list-inline-item">
                            <a href="https://twitter.com" class="icons d-block">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fab fa-twitter fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                </ul>

                <p class="text-muted">
                    
                        Copyright ? 2008?锟�2020, Steve Francia and the Hugo Authors; All Rights Reserved.
                    
                </p>

                <p class="text-muted">
                Powered by <a href="https://gohugo.io" target="_blank">Hugo</a> with <a href="https://github.com/puresyntax71/hugo-theme-chunky-poster" target="_blank">Chunky Poster</a>.
                Modified by <a href="https://github.com/kangzhiheng" target="_blank">Kangzhiheng</a>.
                </p>
                
                <p class="text-muted">
                    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
                    本文总阅读量
                    <span id="busuanzi_container_page_pv">
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    次，感谢
                    <span id="busuanzi_container_site_uv">
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                    位小伙伴的第
                    <span id="busuanzi_container_site_pv">
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                    次光临
                </p>
            </div>
        </div>
    </div>  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
</footer>


    
    
        
            <script src="/dist/main.d608eadfe5ac0688902e.min.js"></script>
        
    



<script>
    window.Prism = window.Prism || {};
    window.Prism.manual = true;
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/plugins/autoloader/prism-autoloader.min.js"></script>






    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-166758556-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</body>
</html>
